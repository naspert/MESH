/* $Id: model_in_smf.c,v 1.1 2002/08/15 15:39:03 aspert Exp $ */

/*
 *
 *  Copyright (C) 2001-2002 EPFL (Swiss Federal Institute of Technology,
 *  Lausanne) This program is free software; you can redistribute it
 *  and/or modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2 of
 *  the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 *  USA.
 *
 *  In addition, as a special exception, EPFL gives permission to link
 *  the code of this program with the Qt non-commercial edition library
 *  (or with modified versions of Qt non-commercial edition that use the
 *  same license as Qt non-commercial edition), and distribute linked
 *  combinations including the two.  You must obey the GNU General
 *  Public License in all respects for all of the code used other than
 *  Qt non-commercial edition.  If you modify this file, you may extend
 *  this exception to your version of the file, but you are not
 *  obligated to do so.  If you do not wish to do so, delete this
 *  exception statement from your version.
 *
 *  Authors : Nicolas Aspert, Diego Santa-Cruz and Davy Jacquet
 *
 *  Web site : http://mesh.epfl.ch
 *
 *  Reference :
 *   "MESH : Measuring Errors between Surfaces using the Hausdorff distance"
 *   Accepted for publication, ICME 2002, available on http://mesh.epfl.ch
 *
 */
#include <model_in.h>

/* Reads a _triangular_ mesh from a SMF file (used by M. Garland's QSlim).
 * Only the vertices and faces are read. All other possible fields in
 * SMF files (i.e. color, bindings, begin/end, transform ...) are
 * skipped silently. However, this code should be sufficient to read
 * SMF files generated by QSlim ...
 * It returns the number of meshes read (i.e. 1) if successful, and a 
 * negative code if it failed. */
int read_smf_tmesh(struct model **tmesh_ref, struct file_data *data) {
  int  c;
  struct model *tmesh;
  vertex_t bbmin, bbmax;
  int max_vidx=-1;
  int nvtcs=0;
  int nfaces=0;
  int l_vertices=0, l_faces=0;
  int f0, f1, f2;
  float x, y, z;
  int rcode = 1;



  bbmin.x = bbmin.y = bbmin.z = FLT_MAX;
  bbmax.x = bbmax.y = bbmax.z = -FLT_MAX;
  tmesh = (struct model*)calloc(1, sizeof(struct model));

  do {
    c = skip_ws_comm(data);
    if (c == EOF) break; /* maybe ok if we have reached the end of
                          *  file */

    c = getc(data); /* get 1st char of the current line */
    
    switch (c) {
    case 'v': /* vertex line found */
      if (nvtcs == l_vertices) { /* Reallocate storage if needed */
        tmesh->vertices = grow_array(tmesh->vertices, 
                                     sizeof(*(tmesh->vertices)), 
                                     &l_vertices, SZ_MAX_INCR);
        if (tmesh->vertices == NULL) {
          rcode = MESH_NO_MEM;
          break;
        }
      }
      if (float_scanf(data, &x) != 1) {
        rcode = MESH_CORRUPTED;
        break;
      }
      if (float_scanf(data, &y) != 1) {
        rcode = MESH_CORRUPTED;
        break;
      }
      if (float_scanf(data, &z) != 1) {
        rcode = MESH_CORRUPTED;
        break;
      }

#ifdef DEBUG
      printf("[read_smf_tmesh] %f %f %f\n", x, y, z);
#endif

      tmesh->vertices[nvtcs].x = x;
      tmesh->vertices[nvtcs].y = y;
      tmesh->vertices[nvtcs++].z = z;

      if (x < bbmin.x) bbmin.x = x;
      if (x > bbmax.x) bbmax.x = x;
      if (y < bbmin.y) bbmin.y = y;
      if (y > bbmax.y) bbmax.y = y;
      if (z < bbmin.z) bbmin.z = z;
      if (z > bbmax.z) bbmax.z = z;

      break; /* end for 'v' */

    case 'f':/* face line found */
      if (nfaces == l_faces) { /* Reallocate storage if needed */
        tmesh->faces = grow_array(tmesh->faces, sizeof(*(tmesh->faces)), 
                                  &l_faces, SZ_MAX_INCR);
        if (tmesh->faces == NULL) {
          rcode = MESH_NO_MEM;
          break;
        }
      }

      if (int_scanf(data, &f0) != 1) {
        rcode = MESH_CORRUPTED;
        break;
      }
      if (int_scanf(data, &f1) != 1) {
        rcode = MESH_CORRUPTED;
        break;
      }
      if (int_scanf(data, &f2) != 1) {
        rcode = MESH_CORRUPTED;
        break;
      }
#ifdef DEBUG
      printf("[read_smf_tmesh] %d %d %d\n", f0, f1, f2);
#endif
      /* Do not forget that SMF vertex indices start at 1 !! */
      tmesh->faces[nfaces].f0 = --f0;
      tmesh->faces[nfaces].f1 = --f1;
      tmesh->faces[nfaces++].f2 = --f2;

      if (f0 > max_vidx) max_vidx = f0;
      if (f1 > max_vidx) max_vidx = f1;
      if (f2 > max_vidx) max_vidx = f2;

      if (f0 < 0 || f1 < 0 || f2 < 0)
        rcode = MESH_CORRUPTED;

      break; /* end for 'f' */

    default: /* only the faces & vertices are read. We choose to
              *  ignore every other field from the SMF spec. */

      do { /* neither a face, nor a vertex => skip the whole line */
        c = getc(data);
      } while (c != EOF && c != '\n' && c != '\r');

      break;
    }

  } while(c != EOF  && rcode > 0);

  if (max_vidx >= nvtcs)
    rcode = MESH_CORRUPTED;

  if (nvtcs == 0) {
    memset(&bbmin, 0, sizeof(bbmin));
    memset(&bbmax, 0, sizeof(bbmax));
  }
  
  if (rcode > 0) {
    tmesh->bBox[0] = bbmin;
    tmesh->bBox[1] = bbmax;
    tmesh->num_vert = nvtcs;
    tmesh->num_faces = nfaces;
    *tmesh_ref = tmesh;
  } else 
    __free_raw_model(tmesh);
  
  return rcode;
}
